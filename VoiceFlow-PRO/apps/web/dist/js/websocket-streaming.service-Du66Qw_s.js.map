{"version":3,"file":"websocket-streaming.service-Du66Qw_s.js","sources":["../../src/services/websocket-streaming.service.ts"],"sourcesContent":["/**\n * WebSocket Streaming Service\n * Real-time audio streaming for live transcription\n * Supports AIML API Deepgram Nova-2 streaming\n */\n\nimport { TranscriptionSegment } from '@/types';\n\n// WebSocket Configuration\nconst WS_BASE_URL = import.meta.env.VITE_AIML_WS_URL || 'wss://api.aimlapi.com/v1/realtime';\nconst RECONNECT_DELAY_MS = 2000;\nconst MAX_RECONNECT_ATTEMPTS = 5;\nconst PING_INTERVAL_MS = 30000;\nconst AUDIO_CHUNK_SIZE_MS = 250; // Send audio chunks every 250ms\n\nexport interface StreamingOptions {\n  language?: string;\n  model?: string;\n  punctuate?: boolean;\n  diarize?: boolean;\n  interimResults?: boolean;\n  professionalMode?: string;\n}\n\nexport interface StreamingTranscript {\n  text: string;\n  isFinal: boolean;\n  confidence: number;\n  timestamp: number;\n  words?: Array<{\n    word: string;\n    start: number;\n    end: number;\n    confidence: number;\n  }>;\n}\n\nexport type StreamingEventType = \n  | 'connected'\n  | 'disconnected'\n  | 'transcript'\n  | 'error'\n  | 'status';\n\nexport type StreamingEventHandler = (data: any) => void;\n\n/**\n * WebSocket Streaming Manager\n * Handles real-time audio streaming and transcription\n */\nexport class WebSocketStreamingService {\n  private ws: WebSocket | null = null;\n  private apiKey: string;\n  private reconnectAttempts = 0;\n  private reconnectTimer: NodeJS.Timeout | null = null;\n  private pingTimer: NodeJS.Timeout | null = null;\n  private isConnecting = false;\n  private isStreaming = false;\n  private eventHandlers: Map<StreamingEventType, Set<StreamingEventHandler>> = new Map();\n  private audioContext: AudioContext | null = null;\n  private mediaRecorder: MediaRecorder | null = null;\n  private audioWorkletNode: AudioWorkletNode | null = null;\n\n  constructor(apiKey: string) {\n    this.apiKey = apiKey;\n    this.initializeEventHandlers();\n  }\n\n  private initializeEventHandlers(): void {\n    this.eventHandlers.set('connected', new Set());\n    this.eventHandlers.set('disconnected', new Set());\n    this.eventHandlers.set('transcript', new Set());\n    this.eventHandlers.set('error', new Set());\n    this.eventHandlers.set('status', new Set());\n  }\n\n  /**\n   * Register event handler\n   */\n  on(event: StreamingEventType, handler: StreamingEventHandler): void {\n    const handlers = this.eventHandlers.get(event);\n    if (handlers) {\n      handlers.add(handler);\n    }\n  }\n\n  /**\n   * Unregister event handler\n   */\n  off(event: StreamingEventType, handler: StreamingEventHandler): void {\n    const handlers = this.eventHandlers.get(event);\n    if (handlers) {\n      handlers.delete(handler);\n    }\n  }\n\n  /**\n   * Emit event to all registered handlers\n   */\n  private emit(event: StreamingEventType, data: any): void {\n    const handlers = this.eventHandlers.get(event);\n    if (handlers) {\n      handlers.forEach(handler => {\n        try {\n          handler(data);\n        } catch (error) {\n          console.error(`Error in ${event} handler:`, error);\n        }\n      });\n    }\n  }\n\n  /**\n   * Connect to WebSocket server\n   */\n  async connect(options: StreamingOptions = {}): Promise<void> {\n    if (this.ws?.readyState === WebSocket.OPEN) {\n      console.log('WebSocket already connected');\n      return;\n    }\n\n    if (this.isConnecting) {\n      console.log('WebSocket connection already in progress');\n      return;\n    }\n\n    this.isConnecting = true;\n\n    return new Promise((resolve, reject) => {\n      try {\n        // Build WebSocket URL with query parameters\n        const url = new URL(WS_BASE_URL);\n        url.searchParams.set('language', options.language || 'en');\n        url.searchParams.set('model', options.model || '#g1_nova-2-general');\n        url.searchParams.set('punctuate', String(options.punctuate !== false));\n        url.searchParams.set('diarize', String(options.diarize || false));\n        url.searchParams.set('interim_results', String(options.interimResults !== false));\n\n        this.ws = new WebSocket(url.toString());\n\n        this.ws.onopen = () => {\n          console.log('âœ… WebSocket connected');\n          this.isConnecting = false;\n          this.reconnectAttempts = 0;\n          \n          // Authenticate\n          this.sendMessage({\n            type: 'auth',\n            token: this.apiKey,\n          });\n\n          // Start ping interval\n          this.startPingInterval();\n\n          this.emit('connected', { timestamp: Date.now() });\n          resolve();\n        };\n\n        this.ws.onmessage = (event) => {\n          this.handleMessage(event.data);\n        };\n\n        this.ws.onerror = (error) => {\n          console.error('âŒ WebSocket error:', error);\n          this.isConnecting = false;\n          this.emit('error', { error: 'WebSocket connection error', timestamp: Date.now() });\n          reject(error);\n        };\n\n        this.ws.onclose = (event) => {\n          console.log('ðŸ”Œ WebSocket closed:', event.code, event.reason);\n          this.isConnecting = false;\n          this.stopPingInterval();\n          this.emit('disconnected', { code: event.code, reason: event.reason, timestamp: Date.now() });\n\n          // Attempt reconnection if not a clean close\n          if (event.code !== 1000 && this.reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {\n            this.scheduleReconnect(options);\n          }\n        };\n\n      } catch (error) {\n        this.isConnecting = false;\n        console.error('Failed to create WebSocket:', error);\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Schedule reconnection attempt\n   */\n  private scheduleReconnect(options: StreamingOptions): void {\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer);\n    }\n\n    this.reconnectAttempts++;\n    const delay = RECONNECT_DELAY_MS * Math.pow(2, this.reconnectAttempts - 1); // Exponential backoff\n\n    console.log(`Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})`);\n\n    this.reconnectTimer = setTimeout(() => {\n      this.connect(options).catch(error => {\n        console.error('Reconnection failed:', error);\n      });\n    }, delay);\n  }\n\n  /**\n   * Start ping interval to keep connection alive\n   */\n  private startPingInterval(): void {\n    this.stopPingInterval();\n    \n    this.pingTimer = setInterval(() => {\n      if (this.ws?.readyState === WebSocket.OPEN) {\n        this.sendMessage({ type: 'ping' });\n      }\n    }, PING_INTERVAL_MS);\n  }\n\n  /**\n   * Stop ping interval\n   */\n  private stopPingInterval(): void {\n    if (this.pingTimer) {\n      clearInterval(this.pingTimer);\n      this.pingTimer = null;\n    }\n  }\n\n  /**\n   * Handle incoming WebSocket message\n   */\n  private handleMessage(data: string): void {\n    try {\n      const message = JSON.parse(data);\n\n      switch (message.type) {\n        case 'auth_success':\n          console.log('âœ… Authentication successful');\n          this.emit('status', { status: 'authenticated', timestamp: Date.now() });\n          break;\n\n        case 'transcript':\n        case 'transcription':\n          this.handleTranscript(message);\n          break;\n\n        case 'error':\n          console.error('Server error:', message.error);\n          this.emit('error', { error: message.error, timestamp: Date.now() });\n          break;\n\n        case 'pong':\n          // Ping response received\n          break;\n\n        default:\n          console.log('Unknown message type:', message.type);\n      }\n    } catch (error) {\n      console.error('Failed to parse WebSocket message:', error);\n    }\n  }\n\n  /**\n   * Handle transcript message\n   */\n  private handleTranscript(message: any): void {\n    const transcript: StreamingTranscript = {\n      text: message.text || message.transcript || '',\n      isFinal: message.is_final || message.isFinal || false,\n      confidence: message.confidence || 0.9,\n      timestamp: message.timestamp || Date.now(),\n      words: message.words || [],\n    };\n\n    this.emit('transcript', transcript);\n  }\n\n  /**\n   * Send message to WebSocket server\n   */\n  private sendMessage(message: any): void {\n    if (this.ws?.readyState === WebSocket.OPEN) {\n      this.ws.send(JSON.stringify(message));\n    } else {\n      console.warn('Cannot send message: WebSocket not connected');\n    }\n  }\n\n  /**\n   * Start streaming audio from MediaStream\n   */\n  async startStreaming(mediaStream: MediaStream): Promise<void> {\n    if (this.isStreaming) {\n      console.warn('Already streaming');\n      return;\n    }\n\n    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {\n      throw new Error('WebSocket not connected. Call connect() first.');\n    }\n\n    this.isStreaming = true;\n\n    // Send start command\n    this.sendMessage({\n      type: 'start_listening',\n      timestamp: Date.now(),\n    });\n\n    // Initialize audio processing\n    await this.initializeAudioProcessing(mediaStream);\n\n    this.emit('status', { status: 'streaming', timestamp: Date.now() });\n  }\n\n  /**\n   * Initialize audio processing and streaming\n   */\n  private async initializeAudioProcessing(mediaStream: MediaStream): Promise<void> {\n    // Create audio context\n    this.audioContext = new AudioContext({ sampleRate: 16000 }); // Deepgram prefers 16kHz\n\n    // Create media stream source\n    const source = this.audioContext.createMediaStreamSource(mediaStream);\n\n    // Use ScriptProcessorNode for audio processing (deprecated but widely supported)\n    // TODO: Migrate to AudioWorklet for better performance\n    const processor = this.audioContext.createScriptProcessor(4096, 1, 1);\n\n    processor.onaudioprocess = (event) => {\n      if (!this.isStreaming) return;\n\n      const inputData = event.inputBuffer.getChannelData(0);\n      \n      // Convert Float32Array to Int16Array (PCM 16-bit)\n      const pcmData = this.float32ToInt16(inputData);\n      \n      // Send audio chunk to server\n      this.sendAudioChunk(pcmData);\n    };\n\n    source.connect(processor);\n    processor.connect(this.audioContext.destination);\n  }\n\n  /**\n   * Convert Float32Array to Int16Array (PCM 16-bit)\n   */\n  private float32ToInt16(float32Array: Float32Array): Int16Array {\n    const int16Array = new Int16Array(float32Array.length);\n    for (let i = 0; i < float32Array.length; i++) {\n      const s = Math.max(-1, Math.min(1, float32Array[i]));\n      int16Array[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;\n    }\n    return int16Array;\n  }\n\n  /**\n   * Send audio chunk to server\n   */\n  private sendAudioChunk(audioData: Int16Array): void {\n    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) return;\n\n    // Convert to base64\n    const base64Audio = this.arrayBufferToBase64(audioData.buffer);\n\n    this.sendMessage({\n      type: 'audio_chunk',\n      data: base64Audio,\n      timestamp: Date.now(),\n    });\n  }\n\n  /**\n   * Convert ArrayBuffer to base64\n   */\n  private arrayBufferToBase64(buffer: ArrayBuffer): string {\n    const bytes = new Uint8Array(buffer);\n    let binary = '';\n    for (let i = 0; i < bytes.byteLength; i++) {\n      binary += String.fromCharCode(bytes[i]);\n    }\n    return btoa(binary);\n  }\n\n  /**\n   * Stop streaming audio\n   */\n  stopStreaming(): void {\n    if (!this.isStreaming) return;\n\n    this.isStreaming = false;\n\n    // Send stop command\n    this.sendMessage({\n      type: 'stop_listening',\n      timestamp: Date.now(),\n    });\n\n    // Clean up audio processing\n    if (this.audioContext) {\n      this.audioContext.close();\n      this.audioContext = null;\n    }\n\n    this.emit('status', { status: 'stopped', timestamp: Date.now() });\n  }\n\n  /**\n   * Disconnect WebSocket\n   */\n  disconnect(): void {\n    this.stopStreaming();\n    this.stopPingInterval();\n\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer);\n      this.reconnectTimer = null;\n    }\n\n    if (this.ws) {\n      this.ws.close(1000, 'Client disconnect');\n      this.ws = null;\n    }\n\n    this.reconnectAttempts = 0;\n  }\n\n  /**\n   * Check if connected\n   */\n  isConnected(): boolean {\n    return this.ws?.readyState === WebSocket.OPEN;\n  }\n\n  /**\n   * Get connection state\n   */\n  getState(): string {\n    if (!this.ws) return 'disconnected';\n    \n    switch (this.ws.readyState) {\n      case WebSocket.CONNECTING: return 'connecting';\n      case WebSocket.OPEN: return 'connected';\n      case WebSocket.CLOSING: return 'closing';\n      case WebSocket.CLOSED: return 'disconnected';\n      default: return 'unknown';\n    }\n  }\n}\n\n// Export singleton instance\nlet streamingServiceInstance: WebSocketStreamingService | null = null;\n\nexport function getStreamingService(apiKey?: string): WebSocketStreamingService {\n  if (!streamingServiceInstance && apiKey) {\n    streamingServiceInstance = new WebSocketStreamingService(apiKey);\n  }\n  \n  if (!streamingServiceInstance) {\n    throw new Error('Streaming service not initialized. Provide API key on first call.');\n  }\n  \n  return streamingServiceInstance;\n}\n\n"],"names":[],"mappings":";;;AASA,MAAM,cAAkD;AACxD,MAAM,qBAAqB;AAC3B,MAAM,yBAAyB;AAC/B,MAAM,mBAAmB;AAsClB,MAAM,0BAA0B;AAAA,EAarC,YAAY,QAAgB;AAZ5B,kBAAA,MAAQ,MAAuB,IAAA;AAC/B,kBAAA,MAAQ,QAAA;AACR,kBAAA,MAAQ,qBAAoB,CAAA;AAC5B,kBAAA,MAAQ,kBAAwC,IAAA;AAChD,kBAAA,MAAQ,aAAmC,IAAA;AAC3C,kBAAA,MAAQ,gBAAe,KAAA;AACvB,kBAAA,MAAQ,eAAc,KAAA;AACtB,kBAAA,MAAQ,qCAAyE,IAAA,CAAI;AACrF,kBAAA,MAAQ,gBAAoC,IAAA;AAC5C,kBAAA,MAAQ,iBAAsC,IAAA;AAC9C,kBAAA,MAAQ,oBAA4C,IAAA;AAGlD,SAAK,SAAS;AACd,SAAK,wBAAA;AAAA,EACP;AAAA,EAEQ,0BAAgC;AACtC,SAAK,cAAc,IAAI,aAAa,oBAAI,KAAK;AAC7C,SAAK,cAAc,IAAI,gBAAgB,oBAAI,KAAK;AAChD,SAAK,cAAc,IAAI,cAAc,oBAAI,KAAK;AAC9C,SAAK,cAAc,IAAI,SAAS,oBAAI,KAAK;AACzC,SAAK,cAAc,IAAI,UAAU,oBAAI,KAAK;AAAA,EAC5C;AAAA;AAAA;AAAA;AAAA,EAKA,GAAG,OAA2B,SAAsC;AAClE,UAAM,WAAW,KAAK,cAAc,IAAI,KAAK;AAC7C,QAAI,UAAU;AACZ,eAAS,IAAI,OAAO;AAAA,IACtB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,OAA2B,SAAsC;AACnE,UAAM,WAAW,KAAK,cAAc,IAAI,KAAK;AAC7C,QAAI,UAAU;AACZ,eAAS,OAAO,OAAO;AAAA,IACzB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,KAAK,OAA2B,MAAiB;AACvD,UAAM,WAAW,KAAK,cAAc,IAAI,KAAK;AAC7C,QAAI,UAAU;AACZ,eAAS,QAAQ,CAAA,YAAW;AAC1B,YAAI;AACF,kBAAQ,IAAI;AAAA,QACd,SAAS,OAAO;AACd,kBAAQ,MAAM,YAAY,KAAK,aAAa,KAAK;AAAA,QACnD;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,QAAQ,UAA4B,IAAmB;;AAC3D,UAAI,UAAK,OAAL,mBAAS,gBAAe,UAAU,MAAM;AAC1C,cAAQ,IAAI,6BAA6B;AACzC;AAAA,IACF;AAEA,QAAI,KAAK,cAAc;AACrB,cAAQ,IAAI,0CAA0C;AACtD;AAAA,IACF;AAEA,SAAK,eAAe;AAEpB,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,UAAI;AAEF,cAAM,MAAM,IAAI,IAAI,WAAW;AAC/B,YAAI,aAAa,IAAI,YAAY,QAAQ,YAAY,IAAI;AACzD,YAAI,aAAa,IAAI,SAAS,QAAQ,SAAS,oBAAoB;AACnE,YAAI,aAAa,IAAI,aAAa,OAAO,QAAQ,cAAc,KAAK,CAAC;AACrE,YAAI,aAAa,IAAI,WAAW,OAAO,QAAQ,WAAW,KAAK,CAAC;AAChE,YAAI,aAAa,IAAI,mBAAmB,OAAO,QAAQ,mBAAmB,KAAK,CAAC;AAEhF,aAAK,KAAK,IAAI,UAAU,IAAI,UAAU;AAEtC,aAAK,GAAG,SAAS,MAAM;AACrB,kBAAQ,IAAI,uBAAuB;AACnC,eAAK,eAAe;AACpB,eAAK,oBAAoB;AAGzB,eAAK,YAAY;AAAA,YACf,MAAM;AAAA,YACN,OAAO,KAAK;AAAA,UAAA,CACb;AAGD,eAAK,kBAAA;AAEL,eAAK,KAAK,aAAa,EAAE,WAAW,KAAK,IAAA,GAAO;AAChD,kBAAA;AAAA,QACF;AAEA,aAAK,GAAG,YAAY,CAAC,UAAU;AAC7B,eAAK,cAAc,MAAM,IAAI;AAAA,QAC/B;AAEA,aAAK,GAAG,UAAU,CAAC,UAAU;AAC3B,kBAAQ,MAAM,sBAAsB,KAAK;AACzC,eAAK,eAAe;AACpB,eAAK,KAAK,SAAS,EAAE,OAAO,8BAA8B,WAAW,KAAK,IAAA,GAAO;AACjF,iBAAO,KAAK;AAAA,QACd;AAEA,aAAK,GAAG,UAAU,CAAC,UAAU;AAC3B,kBAAQ,IAAI,wBAAwB,MAAM,MAAM,MAAM,MAAM;AAC5D,eAAK,eAAe;AACpB,eAAK,iBAAA;AACL,eAAK,KAAK,gBAAgB,EAAE,MAAM,MAAM,MAAM,QAAQ,MAAM,QAAQ,WAAW,KAAK,IAAA,GAAO;AAG3F,cAAI,MAAM,SAAS,OAAQ,KAAK,oBAAoB,wBAAwB;AAC1E,iBAAK,kBAAkB,OAAO;AAAA,UAChC;AAAA,QACF;AAAA,MAEF,SAAS,OAAO;AACd,aAAK,eAAe;AACpB,gBAAQ,MAAM,+BAA+B,KAAK;AAClD,eAAO,KAAK;AAAA,MACd;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAKQ,kBAAkB,SAAiC;AACzD,QAAI,KAAK,gBAAgB;AACvB,mBAAa,KAAK,cAAc;AAAA,IAClC;AAEA,SAAK;AACL,UAAM,QAAQ,qBAAqB,KAAK,IAAI,GAAG,KAAK,oBAAoB,CAAC;AAEzE,YAAQ,IAAI,mBAAmB,KAAK,eAAe,KAAK,iBAAiB,IAAI,sBAAsB,GAAG;AAEtG,SAAK,iBAAiB,WAAW,MAAM;AACrC,WAAK,QAAQ,OAAO,EAAE,MAAM,CAAA,UAAS;AACnC,gBAAQ,MAAM,wBAAwB,KAAK;AAAA,MAC7C,CAAC;AAAA,IACH,GAAG,KAAK;AAAA,EACV;AAAA;AAAA;AAAA;AAAA,EAKQ,oBAA0B;AAChC,SAAK,iBAAA;AAEL,SAAK,YAAY,YAAY,MAAM;;AACjC,YAAI,UAAK,OAAL,mBAAS,gBAAe,UAAU,MAAM;AAC1C,aAAK,YAAY,EAAE,MAAM,OAAA,CAAQ;AAAA,MACnC;AAAA,IACF,GAAG,gBAAgB;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA,EAKQ,mBAAyB;AAC/B,QAAI,KAAK,WAAW;AAClB,oBAAc,KAAK,SAAS;AAC5B,WAAK,YAAY;AAAA,IACnB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,cAAc,MAAoB;AACxC,QAAI;AACF,YAAM,UAAU,KAAK,MAAM,IAAI;AAE/B,cAAQ,QAAQ,MAAA;AAAA,QACd,KAAK;AACH,kBAAQ,IAAI,6BAA6B;AACzC,eAAK,KAAK,UAAU,EAAE,QAAQ,iBAAiB,WAAW,KAAK,IAAA,GAAO;AACtE;AAAA,QAEF,KAAK;AAAA,QACL,KAAK;AACH,eAAK,iBAAiB,OAAO;AAC7B;AAAA,QAEF,KAAK;AACH,kBAAQ,MAAM,iBAAiB,QAAQ,KAAK;AAC5C,eAAK,KAAK,SAAS,EAAE,OAAO,QAAQ,OAAO,WAAW,KAAK,IAAA,GAAO;AAClE;AAAA,QAEF,KAAK;AAEH;AAAA,QAEF;AACE,kBAAQ,IAAI,yBAAyB,QAAQ,IAAI;AAAA,MAAA;AAAA,IAEvD,SAAS,OAAO;AACd,cAAQ,MAAM,sCAAsC,KAAK;AAAA,IAC3D;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,iBAAiB,SAAoB;AAC3C,UAAM,aAAkC;AAAA,MACtC,MAAM,QAAQ,QAAQ,QAAQ,cAAc;AAAA,MAC5C,SAAS,QAAQ,YAAY,QAAQ,WAAW;AAAA,MAChD,YAAY,QAAQ,cAAc;AAAA,MAClC,WAAW,QAAQ,aAAa,KAAK,IAAA;AAAA,MACrC,OAAO,QAAQ,SAAS,CAAA;AAAA,IAAC;AAG3B,SAAK,KAAK,cAAc,UAAU;AAAA,EACpC;AAAA;AAAA;AAAA;AAAA,EAKQ,YAAY,SAAoB;;AACtC,UAAI,UAAK,OAAL,mBAAS,gBAAe,UAAU,MAAM;AAC1C,WAAK,GAAG,KAAK,KAAK,UAAU,OAAO,CAAC;AAAA,IACtC,OAAO;AACL,cAAQ,KAAK,8CAA8C;AAAA,IAC7D;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,eAAe,aAAyC;AAC5D,QAAI,KAAK,aAAa;AACpB,cAAQ,KAAK,mBAAmB;AAChC;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,MAAM,KAAK,GAAG,eAAe,UAAU,MAAM;AACrD,YAAM,IAAI,MAAM,gDAAgD;AAAA,IAClE;AAEA,SAAK,cAAc;AAGnB,SAAK,YAAY;AAAA,MACf,MAAM;AAAA,MACN,WAAW,KAAK,IAAA;AAAA,IAAI,CACrB;AAGD,UAAM,KAAK,0BAA0B,WAAW;AAEhD,SAAK,KAAK,UAAU,EAAE,QAAQ,aAAa,WAAW,KAAK,IAAA,GAAO;AAAA,EACpE;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,0BAA0B,aAAyC;AAE/E,SAAK,eAAe,IAAI,aAAa,EAAE,YAAY,MAAO;AAG1D,UAAM,SAAS,KAAK,aAAa,wBAAwB,WAAW;AAIpE,UAAM,YAAY,KAAK,aAAa,sBAAsB,MAAM,GAAG,CAAC;AAEpE,cAAU,iBAAiB,CAAC,UAAU;AACpC,UAAI,CAAC,KAAK,YAAa;AAEvB,YAAM,YAAY,MAAM,YAAY,eAAe,CAAC;AAGpD,YAAM,UAAU,KAAK,eAAe,SAAS;AAG7C,WAAK,eAAe,OAAO;AAAA,IAC7B;AAEA,WAAO,QAAQ,SAAS;AACxB,cAAU,QAAQ,KAAK,aAAa,WAAW;AAAA,EACjD;AAAA;AAAA;AAAA;AAAA,EAKQ,eAAe,cAAwC;AAC7D,UAAM,aAAa,IAAI,WAAW,aAAa,MAAM;AACrD,aAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,KAAK;AAC5C,YAAM,IAAI,KAAK,IAAI,IAAI,KAAK,IAAI,GAAG,aAAa,CAAC,CAAC,CAAC;AACnD,iBAAW,CAAC,IAAI,IAAI,IAAI,IAAI,QAAS,IAAI;AAAA,IAC3C;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKQ,eAAe,WAA6B;AAClD,QAAI,CAAC,KAAK,MAAM,KAAK,GAAG,eAAe,UAAU,KAAM;AAGvD,UAAM,cAAc,KAAK,oBAAoB,UAAU,MAAM;AAE7D,SAAK,YAAY;AAAA,MACf,MAAM;AAAA,MACN,MAAM;AAAA,MACN,WAAW,KAAK,IAAA;AAAA,IAAI,CACrB;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAKQ,oBAAoB,QAA6B;AACvD,UAAM,QAAQ,IAAI,WAAW,MAAM;AACnC,QAAI,SAAS;AACb,aAAS,IAAI,GAAG,IAAI,MAAM,YAAY,KAAK;AACzC,gBAAU,OAAO,aAAa,MAAM,CAAC,CAAC;AAAA,IACxC;AACA,WAAO,KAAK,MAAM;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA,EAKA,gBAAsB;AACpB,QAAI,CAAC,KAAK,YAAa;AAEvB,SAAK,cAAc;AAGnB,SAAK,YAAY;AAAA,MACf,MAAM;AAAA,MACN,WAAW,KAAK,IAAA;AAAA,IAAI,CACrB;AAGD,QAAI,KAAK,cAAc;AACrB,WAAK,aAAa,MAAA;AAClB,WAAK,eAAe;AAAA,IACtB;AAEA,SAAK,KAAK,UAAU,EAAE,QAAQ,WAAW,WAAW,KAAK,IAAA,GAAO;AAAA,EAClE;AAAA;AAAA;AAAA;AAAA,EAKA,aAAmB;AACjB,SAAK,cAAA;AACL,SAAK,iBAAA;AAEL,QAAI,KAAK,gBAAgB;AACvB,mBAAa,KAAK,cAAc;AAChC,WAAK,iBAAiB;AAAA,IACxB;AAEA,QAAI,KAAK,IAAI;AACX,WAAK,GAAG,MAAM,KAAM,mBAAmB;AACvC,WAAK,KAAK;AAAA,IACZ;AAEA,SAAK,oBAAoB;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA,EAKA,cAAuB;;AACrB,aAAO,UAAK,OAAL,mBAAS,gBAAe,UAAU;AAAA,EAC3C;AAAA;AAAA;AAAA;AAAA,EAKA,WAAmB;AACjB,QAAI,CAAC,KAAK,GAAI,QAAO;AAErB,YAAQ,KAAK,GAAG,YAAA;AAAA,MACd,KAAK,UAAU;AAAY,eAAO;AAAA,MAClC,KAAK,UAAU;AAAM,eAAO;AAAA,MAC5B,KAAK,UAAU;AAAS,eAAO;AAAA,MAC/B,KAAK,UAAU;AAAQ,eAAO;AAAA,MAC9B;AAAS,eAAO;AAAA,IAAA;AAAA,EAEpB;AACF;AAGA,IAAI,2BAA6D;AAE1D,SAAS,oBAAoB,QAA4C;AAC9E,MAAI,CAAC,4BAA4B,QAAQ;AACvC,+BAA2B,IAAI,0BAA0B,MAAM;AAAA,EACjE;AAEA,MAAI,CAAC,0BAA0B;AAC7B,UAAM,IAAI,MAAM,mEAAmE;AAAA,EACrF;AAEA,SAAO;AACT;"}